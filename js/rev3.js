let Document = {
    text: [],
    eventLog: [],
    textLog: [],
    body: [],
    edges: [],
    createTimeStamp: function(){
        //creates a timeStamp
        let date = new Date();
        return date.getTime();
    },
    createEdge: function(edgeValue, edgeMessage){
        //Creates a list of all edge cases accounted for
        let Edge = {
            id: createKey(),
            value: edgeValue,
            timeStamp: Document.createTimeStamp,
            message: edgeMessage,
        }
        Document.edges.push(Edge);
    },

    debugText: function(){
        console.log(this.text);
    },
    debugTextLog: function(){
        console.log(this.textLog);
    },
    debugEventLog: function(){
        console.log(this.eventLog);
    },
    updateKeyboard: function(){
        //this.textLog.forEach(function(){
        //https://codepen.io/gschier/pen/VKgyaY
        //    console.log("I'll use this to create a heat map of keys later.");
        //});
    },
    bodyDebug: function(){
        console.log(Document.body);
    },
}

function Record(eventObject, objectData, objectEventType, objectTimeStamp){
    this.recorded = eventObject;
    this.text = objectData;
    this.event = objectEventType;
    this.timeStamp = objectTimeStamp;
}

let Words = {
    globalWords: [],
    words: [],
    wordCount: 0,
    wordLengths: [],
    syllables:[],
    breaths: [],

    processWords: function(sentence){
        //remove all non-word characters
        sentence = sentence.replace(/[\W_]+/g," ");
        //Split words from sentence by spaces
        let words = sentence.split(" ");
        //Define a new Word Bank
        let Bank = new Object;
        //Initailize empty arrays for word lengths, how many, and the words themselves
        Bank.lengths = [];
        Bank.count = 0;
        Bank.words = [];
        Bank.syllables = [];
        Bank.breaths = [];
        //Initialize a wordCount variable
        let wordCount = 0;
        //For each of the words generated by the split
        words.forEach(function(word){
            if(word.length > 0){
                wordCount = wordCount + 1;
                console.log("Beginning:" +  word);
                let syllableCount = getSyllableCount(word);
                console.log("End");
                Bank.syllables.push(syllableCount);
                //Add a copy of the word in the word Bank
                Bank.words.push(word);
                //Add word lengths to the word Bank
                Bank.lengths.push(word.length);
                //Create breath unit variable
                let breath = (word.length/syllableCount).toFixed(2);
                //Add breath units to word Bank
                Bank.breaths.push(breath);

                //Add syllable counts to global Words
                Words.syllables.push(syllableCount);
                //Add word to the global Words
                Words.globalWords.push(word);
                //Add length to the global Words
                Words.wordLengths.push(word.length);
                //Add breath unit to global Words
                Words.breaths.push(breath);
            }else{
                //Creates and edge case for word filtering, should output spaces and whitespace.
                Document.createEdge(word, "Created during word filtering.");
            }
        });
        //Add the number of words to the Bank
        Bank.count = wordCount;
        //Push copy of word bank into global word bank
        Words.wordCount = wordCount;
        //Return Bank to Sentences
        return Bank;
    },
}

let Sentences = {
    sentences: [],
    sentenceCount: 0,
    fragmentCount: 0,
    splitFragments: function(sentence){
        //Create a copy of sentence to filter common punctuation for fragments
        let mutableSentence = sentence;
        //replace commas with tag
        mutableSentence = mutableSentence.replace(/\,/g, "$*");
        //replace parethesis with tag
        mutableSentence = mutableSentence.replace(/\(/g, "$*");
        //replace parethesis with tag
        mutableSentence = mutableSentence.replace(/\)/g, "$*");
        //replace brackets with tag
        mutableSentence = mutableSentence.replace(/\[/g, "$*");
        //replace brackets with tag
        mutableSentence = mutableSentence.replace(/\]/g, "$*");
        //replace colon with tag
        mutableSentence = mutableSentence.replace(/\:/g, "$*");
        //replace semicolon with tag
        mutableSentence = mutableSentence.replace(/\;/g, "$*");
        //return array of fragments
        return mutableSentence.split("$*");
    },
    splitPunctuation: function(paragraph){
        //Remove some simple cases of punctuation
        paragraph = paragraph.replace("!", ".");
        paragraph = paragraph.replace("?", ".");
        paragraph = paragraph.replace("...", ".");
        //Remove apostrophes (’) and replace with nothing to preserve words
        paragraph = paragraph.replace(/’/g,"");
        //Split paragraph by "SPACE + ." pairs
        //return sentences without punctuations or apostrophes
        return paragraph.split(". ");;
    },
    splitSentences: function(paragraph){
        let paragraphSentences = [];
        //remove common punctuation and split sentence by ". " pairs
        let sentences = Sentences.splitPunctuation(paragraph);
        //For each sentence, remove any edge cases and push to larger object
        sentences.forEach(function(sentence){
            //Make random spaces filter out
            if(sentence.length > 0){
                //Increment the sentenceCount variable
                Sentences.sentenceCount = Sentences.sentenceCount + 1;
                //create Sentence Object to save in sentences array of Sentences Object
                let Sentence = new Object;
                //Add an empty string of sentence to Sentence Object
                Sentence.sentence = "";
                //Push current sentence into into sentence object
                Sentence.sentence = sentence;
                //get word data for sentence
                Sentence.words = Words.processWords(sentence);
                //Add an empty array for fragments
                Sentence.fragments = [];
                //Initialize the fragment count at 0
                Sentence.fragmentCount = 0;
                //Create a variable from sentence split by in-sentence punctuation
                let fragments = Sentences.splitFragments(sentence);
                //Filter out the empty fragments casused by splitting
                fragments.forEach(function(fragment){
                    if(fragment.length > 0){
                        //Increase the count of total fragments
                        Sentence.fragmentCount = Sentence.fragmentCount + 1;
                        //save the "Word" object to a variable
                        let fragmentWordObject = Words.processWords(fragment);
                        //Add original fragment to the Word object
                        fragmentWordObject.original = fragment;
                        //Set fragments to Sentence Object
                        Sentence.fragments.push(fragmentWordObject);
                    }else{
                        Document.createEdge(fragment, "Created during fragment filtering.");
                    }
                });

                //Save a copy to the sentences object
                Sentences.sentences.push(Sentence);
                //Save a copy to return to paragraph
                paragraphSentences.push(Sentence);
            }else{
                // Creates edge case for sentences, should output spaces and whitespace
                Document.createEdge(sentence, "Created during sentence filtering.");
            }
        });
        return paragraphSentences;
    },
    filterHonora: function(paragraph){
        //create a mutable copy
        let mutableParagraph = paragraph;
        //initialize a count variable to access replacement words for various honorifics
        let corpCount = 0;
        //Find honora
        Corpora.honora.forEach(function(acronyma){
              //Increment the count
              corpCount = corpCount + 1;
              //look for words that match in the paragraph
              let match = paragraph.match(acronyma + ".");
              //If one is found, replace with full word
              if(match){
                  mutableParagraph = mutableParagraph.replace("" + match[0] + "", Corpora.replacement[corpCount - 1]);
              }
              //Edge function not placed here because the edge results would not be useful
        });
        /*
        if (typeof word == 'number') {
          var num2words = new NumberToWords();
          num2words.convert(word); //'eight hundred fifty'
          word = num2words;
        }
        */
        return mutableParagraph;
    },
}

let Paragraphs = {
    paragraphs: [],
    strings: [],
    count: 0,
    process: function(target){
        //get text from input
        let text = document.getElementById("" + target + "").value;
        //Explicitly type as string
        text = text.toString();
        //split text by spaces
        let newlined = text.split("\n");
        //Number of paragraphs
        let paragraphCount = newlined.length;
        newlined.forEach(function(paragraph){
            //Deals with spurious return carriages.
            paragraphCount = paragraphCount - 1;
            //If the paragraph is greater than zero (not just a line-break)
            if(paragraph.length > 0){
                //Increment paragraph counter for this.count
                paragraphCount = paragraphCount + 1;
                //Add paragraphs to Paragraph Object
                Paragraphs.strings.push(paragraph);
                //Begin sentence filtering
                let sentencesWithoutHonora = Sentences.filterHonora(paragraph);
                //Split Sentences
                let splitSentences = Sentences.splitSentences(paragraph);
                //Create Paragraph object to store sentences
                let Paragraph = new Object;
                //Set original text to Paragraph object
                Paragraph.originText = paragraph;
                //Set split sentences with honora replaced in Paragraph Object
                Paragraph.sentences = splitSentences;
                //push Paragraph object into paragraphs array of Paragraphs object
                Paragraphs.paragraphs.push(Paragraph);
            }else{
                //Records edge cases for paragraph creation, result should be return carriages
                Document.createEdge(paragraph, "Created during paragraph filtering.");
            }
        });
        //Update the paragraph count
        this.count = paragraphCount;
        Document.body = Paragraphs.paragraphs;
        Document.bodyDebug();
    },

    processDebug: function(){
        console.log(this.paragraphs);
        console.log(this.count);
    },
    sentenceDebug: function(){
        Paragraphs.paragraphs.forEach(function(paragraph){
            paragraph.sentences.forEach(function(sentence){
                console.log(sentence);
            });
        });
    },
    fragmentDebug: function(){
      Paragraphs.paragraphs.forEach(function(paragraph){
          paragraph.sentences.forEach(function(sentence){
              console.log(sentence.fragments);
          });
      });
    },
};

let Observer = {
    record: [],
    text: [],
    event: [],
    timeStamp: [],
    keyTimeStamp: [],
    observe: function(object){
        //updates the record log of texts, events, and the time they occured
        this.record.push(object.recorded);
        this.text.push(object.text);
        this.event.push(object.event);
        this.timeStamp.push(object.timeStamp);
        //For typing speed were only interested in key event
        if(object.event == "typed"){
            this.keyTimeStamp.push(object.timeStamp);
        }
        //Edge not created here because data would not be useful
    },
    reveal: function(){
        for (let i = 0; i < this.record.length; i++) {
            console.log("------- Record " + i + "--------");
            console.log(this.record[i]);
            console.log(this.text[i]);
            console.log(this.event[i]);
            console.log(this.timeStamp[i]);
        }
    }
}

let Mediator = {
    update: function(element){
        // get the id of the element were getting data from
        let src = document.getElementById("" + element + "");
        //Only update the current state of chars
        //Keep values of textLog
        Document.text = src.value.split("");
    },
    handleNewPaste: function(event){
        // Stop data actually being pasted
        event.stopPropagation();
        event.preventDefault();
        // Get pasted data via clipboard API
        let clipboardData = event.clipboardData || window.clipboardData;
        let pastedData = clipboardData.getData('Text');
        //split data into characters
        let splitData = pastedData.split("");
        //Add a new record into observer
        let newRecord = new Record(event, splitData, "pasted", event.timeStamp);
        Observer.observe(newRecord);
        //get element id from event
        let src = event.srcElement.id;
        //Paste text as if past event had completed
        insertAtCaret(src, pastedData);
        this.update(src);
    },
    handleNewKey: function(event){
        // Specific character
        key = event.key;
        //Time stamp when entered
        timeStamp = event.timeStamp;
        Document.eventLog.push(event);
        Document.text.push(event.key);
        Document.textLog.push(event.key);
        // get the id of the original src element
        let src = event.srcElement.id;
        //Add a new record into observer
        let newRecord = new Record(event, event.key, "typed", event.timeStamp);
        Observer.observe(newRecord);
        this.update(src);
        Document.updateKeyboard();
    }
}

/*
To dos
- Impliment timestamps throughout objects to track processing speed
- Add Qwerty and Dvorac options to the typing Characteristics
- Make keys on typing characteristics respond when keypress event happens, but only when visible
- Use observer to calculate typing speed
- Use observer and document.textlog to give typing statistics

*/

/*
highlighting syntax
https://markjs.io/
*/
